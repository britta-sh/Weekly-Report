### 第三次周报
***
#### 学习记录
API + JS进阶
##### API
###### 日期对象
1. 实例化
`const date = new Date()`
2. 时间戳
- 获得时间戳
date.getTime()  需要实例化；+new Date()；Date.now()；指定时间戳：+new Date('2024-10-1 18:30:00')
###### 节点操作
1. 查找
- 父节点`子元素.parentNode`
- 子节点 获得所有元素节点 返回伪数组 `父元素.children`
- 兄弟节点
上一个节点：nextElementSibling
下一个节点：previousElementSibling

2. 增加
- 创建 `document.createElement('div')`
- 追加 插入到父元素的最后一个子元素`父元素.appendChild(要插入元素)`
       插入到父元素中某个子元素前面`父元素.insertBefore(要插入元素，在哪个元素前面)`
       放到最前：`ul.insertBefore(li,ul.children[0])`

克隆节点：复制一个节点 放入指定元素内部
`元素.cloneNode(true)`
3. 删除
通过父元素 真的删除
`父元素.removeChild(子元素)`

###### 定时器-延时函数
`setTimeout(回调函数,秒数)`
清除：`let timer = setTimeout(,)`   `clearTimeout(timer)`

###### Location对象
1. href 跳转页面
`location.href = 'https://www.baidu.cn'`
2. search 获取地址中携带的参数 ?之后的 `location.search`
2. hash 获取地址中的哈希值 符号#后面 `location.hash`
3. reload方法 刷新页面
`location.reload()` (true)相当于强制刷新

##### JS进阶
###### 作用域
1. 分类：全局 局部
2. 作用域链：本质是底层的变量查找机制 从下往上
3. 垃圾回收机制：
4. 闭包：内层函数 + 外层函数的变量
```
function outer() {
    let a = 10  //外层函数的变量
    function fu() {  //内层函数
        console.log(a)
    }
    return fu //外面使用a
}
```
5. 变量提升：把所有var声明的变量提升到当前作用域的最前面 值提升声明不提升赋值
###### 函数进阶
1. 函数提升：提前函数声明
2. 函数参数：
- 动态参数 arguments 伪数组
- 剩余参数 ...arr
- 展开运算符 ...arr 展开数组 求数组最大值/合并数组
3. 箭头函数 适用于本来需要匿名函数的地方
- 基本语法：`fun = (x,y) => {...}`
一个参数可以省略小括号；一行代码省略大括号 省略return；直接返回一个对象 用()包上对象{} `fn = (uname) => ({uname:uname})`
- 参数：剩余参数写到(...arr)
- this: 来自上一层
4. 解构赋值
- 数组：把数组里的元素赋值给一系列变量的语法
```
const [max,min,avg] = arr //基本写法
const [a,b,[c,d]] = [1,2,[3,4]]  //多维数组解构
//变量多 单元值少 多的是undefined
//反之 多的剩下
//使用剩余参数 不会有剩下/un(设置默认值)的情况
const [a,b,...c] = [1,2,3,4,5]
const [a = '小米',b = '华为'] = ['苹果']
const [a,b,,d] = [1,2,3,4] //按需导入 c 空的
const [a,b,...c] = [1,2,3,4,5]
```
- 对象
```
//变量名和属性名必须一致
const {uname,age} =  { uname:'lisi',age:18 }
```
属性名冲突 更改对象解构的变量名;数组对象解构;多级对象解构;数组;嵌套
5. forEach() 遍历数组对象
`被遍历数组.forEach(function(当前数组元素，当前元素索引){函数体})`
6. map() 遍历数组并处理每个元素 生成新数组
`被遍历数组.map(function(当前数组元素，当前元素索引){函数体})`
###### 对象
1. 构造函数 以大写字母开头 由new操作符执行
```
function People (uname,age,){
    this.name = uname
    this.age = age
    //不用写return 返回值是创建的对象
}
new People('lisi',19)  //实例化
```
2.实例成员和静态成员
- 实例对象：构造函数创建的对象
- 构造函数中的属性和方法称为静态成员
3. 内置构造函数
- object
Object.keys 获取对象中所有属性名 返回数组；Object.values() 获得所有属性值；拷贝 Object.assign(,) 把后面拷贝给前面
用于给对象添加属性
- array
reduce返回累计处理的结果 经常用于数组求和`arr.reduce(function(上一次值，当前值){},起始值)`
find；every；from
- string
split字符串转换为数组；substring字符串截取；startwith 检测是否以某字符开头；includes
- Number
保留a位小数`num.toFixed(a)`
###### 原型
1. 原型对象：构造函数都有prototype属性 指向另一个对象
把不变的方法/函数 定义到prototype对象上 ，所有对象的实例就可以共享这些方法
构造函数和原型对象的this都指向实例化的对象

2. constructor属性
该属性指向改原型对象的构造函数
用于重新指回创造这个原型对象的构造函数

3. 对象原型
实例对象可以使用原型对象的原因：对象有__proto__原型 [[prototype]]
4. 原型继承
```
//结构一样 对象不一样 构造函数
function Person (){
    this.eyes=2
    this.head=1
}
 
//构造函数
function Woman(){}

//通过原型继承
Woman.prototype = new Person()
//指回原来的构造函数
Woman.prototype.constructor = Woman

//添加方法
woman.prototype.baby = function(){
    log('宝贝')
}

//实例化
const red = new Woman()
log(red)  //2 添加baby之后会有宝贝
```
5. 原型链
###### 深浅拷贝
1. 深拷贝
- 递归函数
```
const deepCopy(newObj,oldObj){
    for(let k in oldObj){
        //  k 属性名  oldObj[k] 属性值
        //处理数组问题
        if(oldObj[k] instanceof Array){
            newObj[k] = []
            deepCopy(newObj[k],oldObj[k])
        } 
        else if (oldObj[k] instanceof Object){
            newObj[k] = {}
            deepCopy(newObj[k],oldObj[k])
        } 
        else {       
            newObj[k] = oldObj[k]
        }
    }
}
```
- lodash/cloneDeep
`o = _.cloneDeep(obj)`
- JSON.stringify()
`o = JSON.parse(JSON.stringify(obj))`
2. 浅拷贝`Object.assign(o,obj)`
###### 处理异常
1. throw抛异常
`throw new error('...')`错误信息
2. try/catch捕获异常
```
try {
    ... //可能发生错误的代码
} catch(err){
    log.(err.message) //打印错误信息
} finally{
    //不论正确与否 都会执行的
}
```
3. debugger
###### 改变this
1. call
调用函数 并且指定this
语法`fun.call(thisArg,arg1,arg2)`
2. apply
调用函数 并且指定this 放数组
语法`fun.call(thisArg,[arg1,arg2])`
3. bind
不会调用函数
语法`fun.bind(thisArg,arg1,arg2)`
相当于返回一个新函数 指定this + 原函数拷贝
###### 性能优化
1. 防抖 lodash库 `_.debounce(func,[wait=0])`
- 手写防抖函数
核心思路：定时器setTimeout
声明定时器变量；鼠标滑动时判断是否有定时器 有就清除以前的；没有就开启 并且存到变量里；在定时器里调用要执行的函数
2. 节流 lodash库 `_.throttle(func,[wait=0])`









